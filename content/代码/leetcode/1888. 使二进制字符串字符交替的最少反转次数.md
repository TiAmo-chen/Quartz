---
title: "二进制字符串最少反转次数算法"
description: "LeetCode 1888题解，通过类型1和类型2操作使二进制字符串变成交替字符串的最少反转次数解法。"
permalink: "/binary-string-minimum-flips"
tags: [LeetCode, 二进制字符串, 字符串操作, 算法, 动态规划]
aliases: [LeetCode, 二进制字符串, 字符串操作, 算法, 动态规划]
created: "2025-11-12"
modified: "2025-11-12"
published: "2025-11-12"
publish: false
draft: true
enableToc: true
lang: "zh-CN"
---

#### [1888. 使二进制字符串字符交替的最少反转次数](https://leetcode.cn/problems/minimum-number-of-flips-to-make-the-binary-string-alternating/)

-  给你一个二进制字符串 s 。你可以按任意顺序执行以下两种操作任意次：

- 类型 1 ：删除 字符串 s 的第一个字符并将它 添加 到字符串结尾。
- 类型 2 ：选择 字符串 s 中任意一个字符并将该字符 反转 ，也就是如果值为 '0' ，则反转得到 '1' ，反之亦然。
- 请你返回使 s 变成 交替 字符串的前提下， 类型 2 的 最少 操作次数 。

- 我们称一个字符串是 交替 的，需要满足任意相邻字符都不同。

- 比方说，字符串 "010" 和 "1010" 都是交替的，但是字符串 "0100" 不是。

![[Pasted image 20230302090921.png]]

***未使用动态规划 ***
```cpp
class Solution {

public:

    int minFlips(string s) {

        int len=s.length();

        int count=0;

        if(len%2!=0)//奇数

        {

            for(;s[0]!=s[len-1];)

            {

                s.push_back(s[0]);

                s.erase(s.begin());

            }

            for(int i=0;i<len-1;i++)

            {

                if(s[i+1]==s[i])

                {

                    s[i+1]=('1' - s[i]) + '0';

                    count++;

                }

            }

            return count < len / 2 ? count : len - count;

        }

        "10001100101000000"

        else//偶数

        {

            for(;s[0]==s[len-1];)

            {

                s.push_back(s[0]);

                s.erase(s.begin());

            }

            for(int i=0;i<len-1;i++)

            {

                if(s[i+1]==s[i])

                {

                    s[i+1]=('1' - s[i]) + '0';

                    count++;

                }

            }

            return count < len / 2 ? count : len - count;

  

        }

    }

};

```

[[动态规划]]



---
title: "排序算法与二分搜索模板"
description: "C++实现的快速排序、归并排序、数组合并和二分搜索算法模板代码合集。"
permalink: "/sorting-and-binary-search-templates"
tags: [C++, 算法, 排序, 二分搜索, 快排, 归并排序]
aliases: [C++, 算法, 排序, 二分搜索, 快排, 归并排序]
created: "2024-12-19"
modified: "2024-12-19"
published: "2024-12-19"
publish: false
draft: false
enableToc: true
lang: "zh-CN"
---

```cpp
//快排
void quick_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int i = l - 1, j = r + 1, x = q[l + r >> 1];
    while (i < j)
    {
        do i ++ ; while (q[i] < x);
        do j -- ; while (q[j] > x);
        if (i < j) swap(q[i], q[j]);
    }
    quick_sort(q, l, j), quick_sort(q, j + 1, r);
}
```


```cpp
//归并
void merge_sort(int q[], int l, int r)
{
    if (l >= r) return;

    int mid = l + r >> 1;
    merge_sort(q, l, mid);
    merge_sort(q, mid + 1, r);
 
    int k = 0, i = l, j = mid + 1;
    while (i <= mid && j <= r)
        if (q[i] <= q[j]) tmp[k ++ ] = q[i ++ ];
        else tmp[k ++ ] = q[j ++ ];

    while (i <= mid) tmp[k ++ ] = q[i ++ ];
    while (j <= r) tmp[k ++ ] = q[j ++ ];

    for (i = l, j = 0; i <= r; i ++, j ++ ) q[i] = tmp[j];
}
```


```cpp

class Solution {
public:
    void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        vector<int>::iterator it1 = nums1.begin(), it2 = nums2.begin(); //一号和二号迭代器
        vector<int>::iterator end1 = nums1.begin() + m, end2 = nums2.begin() + n;//迭代范围
        vector<int> nums(n + m);  //预先声明一个足够大的vector
        vector<int>::iterator it = nums.begin();  //用于存储答案的迭代器
        while (it1 != end1 && it2 != end2) {   //当一号和二号迭代器均未到达终点
            if (*it1 < *it2) {    //选取两个迭代器中更小的
                *it++ = *it1++;
            }else{
                *it++ = *it2++;
            }
        }
        if(it1 == end1)     //当有一个到达终点，直接记录剩下的
            copy(it2, end2, it);
        else if(it2 == end2)
            copy(it1, end1, it);
        copy(nums.begin(), nums.end(), nums1.begin()); //拷贝答案
    }

};
```

```cpp

//整数二分算法模板 —— 模板题 AcWing 789. 数的范围

bool check(int x){} //check用于检测x是否满足某种性质

// 区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：

int bsearch_1(int l,int r)
{
	while(l<r)
	{
		int mid=l+r>>1;
		if (check(mid))
			r=mid;
		else
			l=mid+1;
	}
	return 1;
}


```

![[Pasted image 20230110141331.png]]




